; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\ENGINE.C"
	.assume ADL=1
	SEGMENT BSS
_keepWaterTick:
	DS	1
	SEGMENT CODE
;    1	#include "main.h"
;    2	#include "array.h"
;    3	#include "fire.h"
;    4	#include "tilemap.h"
;    5	#include "sprites.h"
;    6	#include "engine.h"
;    7	#include "graphics.h"
;    8	#include "water.h"
;    9	
;   10	
;   11	bool isSolid(uint8_t tile) {
_isSolid:
;   12		return lookupTile(tile).flags & 0x01;
;   13	}
;   14	
	LD	HL,-7
	CALL	__frameset
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	PEA	IX+-7
	CALL	_lookupTile
	POP	BC
	POP	BC
	LD	IY,HL
	LD	A,(IY+4)
	AND	A,1
	LD	SP,IX
	POP	IX
	RET	


;**************************** _isSolid ***************************
;Name                         Addr/Register   Size   Type
;_lookupTile                         IMPORT  -----   function
;tile                                  IX+6      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   15	bool isPushable(uint8_t tile) {
_isPushable:
	LD	HL,-7
	CALL	__frameset
;   16		return lookupTile(tile).flags & 0x02;
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	PEA	IX+-7
	CALL	_lookupTile
	POP	BC
	POP	BC
	LD	IY,HL
	LD	A,(IY+4)
	AND	A,2
;   17	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _isPushable ***************************
;Name                         Addr/Register   Size   Type
;_lookupTile                         IMPORT  -----   function
;tile                                  IX+6      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   18	
;   19	bool isSpout(uint8_t tile) {
_isSpout:
	LD	HL,-7
	CALL	__frameset
;   20		return lookupTile(tile).flags & 0x4;
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	PEA	IX+-7
	CALL	_lookupTile
	POP	BC
	POP	BC
	LD	IY,HL
	LD	A,(IY+4)
	AND	A,4
;   21	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _isSpout ***************************
;Name                         Addr/Register   Size   Type
;_lookupTile                         IMPORT  -----   function
;tile                                  IX+6      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   22	
;   23	
;   24	/* fetches an X and Y offset based off of the direction
;   25	 * @param d Direction.
;   26	 * @returns a position.*/
;   27	Position facingOffset(Direction d) {
_facingOffset:
	LD	HL,-10
	CALL	__frameset
;   28		const char dx[4] = {-1, 1, 0, 0};
	LEA	DE,IX+-10
	LD	HL,_0temp3
	LD	BC,4
	LDIR	
;   29		const char dy[4] = {0, 0, -1, 1};
	LEA	DE,IX+-6
	LD	HL,_1temp4
	LD	BC,4
	LDIR	
;   30		Position pos;
;   31		pos.x = dx[d];
	LD	BC,(IX+9)
	LEA	HL,IX+-10
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-2),A
;   32		pos.y = dy[d];
	LD	BC,(IX+9)
	LEA	HL,IX+-6
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
;   33		return pos;//newPosition(dx[d], dy[d]);
	LEA	HL,IX+6
	LD	DE,(HL)
	LEA	HL,IX+-2
	LD	BC,2
	LDIR	
	LD	HL,(IX+6)
;   34	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _facingOffset ***************************
;Name                         Addr/Register   Size   Type
;_1temp4                             STATIC      4   variable
;_0temp3                             STATIC      4   variable
;dx                                   IX-10      4   variable
;dy                                    IX-6      4   variable
;pos                                   IX-2      2   variable
;d                                     IX+9      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_0temp3:
	DB	255
	DB	1
	DB	0
	DB	0
_1temp4:
	DB	0
	DB	0
	DB	255
	DB	1
	SEGMENT CODE
;   35	
;   36	
;   37	/* returns a tile given an x and y position.
;   38	 * or returns 1 if off the map
;   39	 * @param row X coordinate of tile
;   40	 * @param column Y coordinate of tile
;   41	 * @returns tile_t.
;   42	 * @see getTile */
;   43	tile_t chkCollision(uint8_t x, uint8_t y) {
_chkCollision:
	LD	HL,-16
	CALL	__frameset
;   44		const uint8_t w = curLevel.width;
	LD	A,(_curLevel+4)
	LD	(IX+-1),A
;   45		const uint8_t h = curLevel.height;
	LD	A,(_curLevel+5)
	LD	(IX+-2),A
;   46	
;   47		if(x > w || x < 0 || y > h || y < 0) {
	LD	A,(IX+-1)
	CP	A,(IX+9)
	JR	C,L_10
	LD	A,(IX+9)
	OR	A,A
	JR	C,L_10
	LD	A,(IX+-2)
	CP	A,(IX+12)
	JR	C,L_10
	LD	A,(IX+12)
	OR	A,A
	JR	NC,L_11
L_10:
;   48			// create a fake tile
;   49			tile_t t = {0};
	LEA	DE,IX+-9
	LD	HL,_2temp9
	LD	BC,7
	LDIR	
;   50			return t;
	LEA	HL,IX+6	; spill
	LD	DE,(HL)
	LEA	HL,IX+-9
	LD	BC,7
	LDIR	
	LD	HL,(IX+6)	; spill
	JR	L_12
;   51		}
;   52		else
L_11:
;   53			return getTile(x, y);
	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	PEA	IX+-16
	CALL	_getTile
	POP	BC
	POP	BC
	POP	BC
	LEA	IY,IX+6
	LD	DE,(IY)
	LD	BC,7
	LDIR	
	LD	HL,(IX+6)
;   54	}
L_12:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _chkCollision ***************************
;Name                         Addr/Register   Size   Type
;_getTile                            IMPORT  -----   function
;_2temp9                             STATIC      7   variable
;_curLevel                           IMPORT      9   variable
;t                                     IX-9      7   variable
;h                                     IX-2      1   variable
;w                                     IX-1      1   variable
;y                                    IX+12      1   parameter
;x                                     IX+9      1   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_2temp9:
	DB	0
	DS	1
	DB	0
	DW	0
	DB	0
	DB	0
	SEGMENT CODE
;   55	
;   56	
;   57	/* gets a copy of the tile at (row, column)
;   58	 * @param row X coordinate of tile
;   59	 * @param column Y coordinate of tile
;   60	 * @returns tile_t. */
;   61	tile_t getTile(uint8_t row, uint8_t column) {
_getTile:
	LD	HL,-1
	CALL	__frameset
;   62		const uint8_t width = curLevel.width;
	LD	A,(_curLevel+4)
	LD	(IX+-1),A
;   63	
;   64		return curLevel.data[column * width + row];
	LD	A,(IX+12)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,7
	CALL	__imul_b
	LD	BC,(_curLevel+6)
	LEA	IY,IX+6
	LD	DE,(IY)
	ADD	HL,BC
	LD	BC,7
	LDIR	
	LD	HL,(IX+6)
;   65	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _getTile ***************************
;Name                         Addr/Register   Size   Type
;_curLevel                           IMPORT      9   variable
;width                                 IX-1      1   variable
;column                               IX+12      1   parameter
;row                                   IX+9      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   66	
;   67	
;   68	
;   69	/* gets a pointer to the tile at (row, column).
;   70	 * @param row X coordinate of tile
;   71	 * @param column Y coordinate of tile
;   72	 * @returns tile_t *. */
;   73	tile_t *getTilePointer(uint8_t row, uint8_t column) {
_getTilePointer:
	LD	HL,-1
	CALL	__frameset
;   74		const uint8_t width = curLevel.width;
	LD	A,(_curLevel+4)
	LD	(IX+-1),A
;   75		return &curLevel.data[column * width + row];
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,7
	CALL	__imul_b
	LD	BC,(_curLevel+6)
	ADD	HL,BC
;   76	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _getTilePointer ***************************
;Name                         Addr/Register   Size   Type
;_curLevel                           IMPORT      9   variable
;width                                 IX-1      1   variable
;column                                IX+9      1   parameter
;row                                   IX+6      1   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;   77	
;   78	
;   79	/* gets a pointer to the tile at (row, column) safely.
;   80	 * @param row X coordinate of tile
;   81	 * @param column Y coordinate of tile
;   82	 * @returns tile_t *. */
;   83	tile_t *getTilePointerSafely(uint8_t row, uint8_t column) {
_getTilePointerSafely:
	LD	HL,-8
	CALL	__frameset
;   84		const uint8_t width = curLevel.width;
	LD	A,(_curLevel+4)
	LD	(IX+-1),A
;   85		const uint8_t height = curLevel.height;
	LD	A,(_curLevel+5)
	LD	(IX+-2),A
;   86		return &curLevel.data[(column >= height ? height-1 : column) * width + (row >= width ? width-1 : row)];
	LD	A,(IX+9)
	CP	A,(IX+-2)
	JR	C,L_17
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+-5),HL
	JR	L_18
L_17:
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	(IX+-5),HL
L_18:
	LD	A,(IX+6)
	CP	A,(IX+-1)
	JR	C,L_21
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+-8),HL
	JR	L_22
L_21:
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	LD	(IX+-8),HL
L_22:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-5)
	CALL	__imuls
	LD	BC,(IX+-8)
	ADD	HL,BC
	LD	A,7
	CALL	__imul_b
	LD	BC,(_curLevel+6)
	ADD	HL,BC
;   87	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _getTilePointerSafely ***************************
;Name                         Addr/Register   Size   Type
;_curLevel                           IMPORT      9   variable
;temp19                                IX-8      3   variable
;temp15                                IX-5      3   variable
;height                                IX-2      1   variable
;width                                 IX-1      1   variable
;column                                IX+9      1   parameter
;row                                   IX+6      1   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


;   88	
;   89	
;   90	/* places a tile at an index.
;   91	 * also draws the tile.
;   92	 * @param row X coordinate of tile
;   93	 * @param column Y coordinate of tile
;   94	 * @param *tile pointer to the draw to write (unchanged).
;   95	 * @returns none. */
;   96	void setTile(uint8_t row, uint8_t column, const tile_t *tile) {
_setTile:
	LD	HL,-8
	CALL	__frameset
;   97		const uint8_t width = curLevel.width;
	LD	A,(_curLevel+4)
	LD	(IX+-1),A
;   98	
;   99		if(tile) {
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	Z,L_26
;  100			curLevel.data[column * width + row] = *tile;
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,7
	CALL	__imul_b
	LD	BC,(_curLevel+6)
	ADD	HL,BC
	LD	DE,HL
	LD	HL,(IX+12)
	LD	BC,7
	LDIR	
;  101			drawTile(*tile, row, column);
	LD	IY,0
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+6)
	PUSH	BC
	LD	HL,(IX+12)
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,7
	ADD	IY,SP
	LD	DE,IY
	LDIR	
	CALL	_drawTile
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  102		} else {
	JR	L_27
L_26:
;  103			tile_t t = {0};
	LEA	DE,IX+-8
	LD	HL,_3temp24
	LD	BC,7
	LDIR	
;  104	
;  105			curLevel.data[column * width + row] = t;
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,7
	CALL	__imul_b
	LD	BC,(_curLevel+6)
	ADD	HL,BC
	LD	DE,HL
	LEA	HL,IX+-8
	LD	BC,7
	LDIR	
;  106			drawTile(t, row, column);
	LD	IY,0
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+6)
	PUSH	BC
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LEA	HL,IX+-8
	LD	BC,7
	ADD	IY,SP
	LD	DE,IY
	LDIR	
	CALL	_drawTile
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  107		}
;  108		
;  109	}
L_27:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _setTile ***************************
;Name                         Addr/Register   Size   Type
;_3temp24                            STATIC      7   variable
;_drawTile                           IMPORT  -----   function
;_curLevel                           IMPORT      9   variable
;t                                     IX-8      7   variable
;width                                 IX-1      1   variable
;tile                                 IX+12      3   parameter
;column                                IX+9      1   parameter
;row                                   IX+6      1   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_3temp24:
	DB	0
	DS	1
	DB	0
	DW	0
	DB	0
	DB	0
	SEGMENT CODE
;  110	
;  111	
;  112	/* called every frame to animate the player. never used
;  113	 * @returns none.*/
;  114	void updatePlayer() {
_updatePlayer:
	LD	HL,-11
	CALL	__frameset
;  115		if(player.dx != 0)
	LD	A,(_player+8)
	OR	A,A
	JR	Z,L_32
;  116			player.dx++;
	LD	A,(_player+8)
	INC	A
	LD	(_player+8),A
L_32:
;  117	
;  118		if(player.dy != 0)
	LD	A,(_player+9)
	OR	A,A
	JR	Z,L_39
;  119			player.dy++;
	LD	A,(_player+9)
	INC	A
	LD	(_player+9),A
L_39:
;  120	
;  121		if(player.dx >= 8 || player.dy >= 8) {
	LD	A,(_player+8)
	CP	A,8
	JR	NC,L_38
	LD	A,(_player+9)
	CP	A,8
	JR	C,L_40
L_38:
;  122			const Position pos = facingOffset(player.direction);
	LD	BC,(_player+2)
	PUSH	BC
	PEA	IX+-4
	CALL	_facingOffset
	POP	BC
	POP	BC
	LEA	DE,IX+-2
	LD	BC,2
	LDIR	
;  123			player.dx = player.dy = 0;
	XOR	A,A
	LD	(_player+9),A
	LD	(_player+8),A
;  124			player.isMoving = false;
	XOR	A,A
	LD	(_player+5),A
;  125			// actually move player
;  126	
;  127			//addPosition(&player.position, pos);
;  128			player.x += (char)pos.x;
	LD	A,(_player)
	ADD	A,(IX+-2)
	LD	(_player),A
;  129			player.y += (char)pos.y;
	LD	A,(_player+1)
	ADD	A,(IX+-1)
	LD	(_player+1),A
;  130	
;  131			// check for starting water flow
;  132			if(chkCollision(player.x, player.y).id == TILE_HANDLE && !player.isWaterFlowing)
	LD	C,A
	LD	A,(_player)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	PEA	IX+-11
	CALL	_chkCollision
	POP	BC
	POP	BC
	POP	BC
	LD	IY,HL
	LD	A,(IY+6)
	CP	A,2
	JR	NZ,L_37
	LD	A,(_player+7)
	OR	A,A
	JR	NZ,L_37
;  133				initFlows();
	CALL	_initFlows
;  134			else if(player.isWaterFlowing) {
	JR	L_40
L_37:
	LD	A,(_player+7)
	OR	A,A
	JR	Z,L_40
;  135				drainWater();
	CALL	_drainWater
;  136			}
;  137		}
;  138		
;  139		
;  140	}
L_40:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _updatePlayer ***************************
;Name                         Addr/Register   Size   Type
;_drainWater                         IMPORT  -----   function
;_initFlows                          IMPORT  -----   function
;_chkCollision                       IMPORT  -----   function
;_facingOffset                       IMPORT  -----   function
;_player                             IMPORT     10   variable
;pos                                   IX-2      2   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


;  141	
;  142	
;  143	void addPosition(Position *self, Position pos) {
_addPosition:
	CALL	__frameset0
;  144		self->x += pos.x;
	LD	A,(IX+9)
	LD	IY,(IX+6)
	ADD	A,(IY+0)
	LD	(IY+0),A
;  145		self->y += pos.y;
	LD	A,(IX+10)
	ADD	A,(IY+1)
	LD	(IY+1),A
;  146	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _addPosition ***************************
;Name                         Addr/Register   Size   Type
;pos                                   IX+9      2   parameter
;self                                  IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  147	
;  148	// this is a dangerous routine because the return struct will get eaten on the stack
;  149	Position newPosition(uint8_t x, uint8_t y) {
_newPosition:
	LD	HL,-2
	CALL	__frameset
;  150		Position pos;
;  151		pos.x = x;
	LD	A,(IX+9)
	LD	(IX+-2),A
;  152		pos.y = y;
	LD	A,(IX+12)
	LD	(IX+-1),A
;  153		
;  154		return pos;
	LEA	HL,IX+6
	LD	DE,(HL)
	LEA	HL,IX+-2
	LD	BC,2
	LDIR	
	LD	HL,(IX+6)
;  155	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _newPosition ***************************
;Name                         Addr/Register   Size   Type
;pos                                   IX-2      2   variable
;y                                    IX+12      1   parameter
;x                                     IX+9      1   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


;  156	
;  157	
;  158	/* opposite of the passed direction.
;  159	 * e.g. LEFT returns RIGHT
;  160	 * @param dir Direction to invert
;  161	 * @returns the opposite direction that is passed.*/
;  162	Direction getOppositeDirection(Direction dir) {
_getOppositeDirection:
	LD	HL,-28
	CALL	__frameset
;  163		const Direction old[] = {LEFT, RIGHT, UP, DOWN};
	LEA	DE,IX+-28
	LD	HL,_4temp43
	LD	BC,12
	LDIR	
;  164		const Direction new[] = {RIGHT, LEFT, DOWN, UP};
	LEA	DE,IX+-16
	LD	HL,_5temp44
	LD	BC,12
	LDIR	
;  165		uint8_t i;
;  166	
;  167		for(i = 0; i < sizeof old; i++) {
	LD	(IX+-1),0
	JR	L_49
L_47:
;  168			if(old[i] == dir) 
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	BC,HL
	LEA	HL,IX+-28
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,(IX+6)
	SBC	HL,BC
	JR	NZ,L_48
;  169				return new[i];
	LD	BC,(IX+-4)
	LEA	HL,IX+-16
	ADD	HL,BC
	LD	HL,(HL)
	JR	L_51
;  170		}
L_48:
	INC	(IX+-1)
L_49:
	LD	A,(IX+-1)
	CP	A,12
	JR	C,L_47
	OR	A,A
;  171	
;  172		return 0; // will always return tho. just to silence the compiler
	SBC	HL,HL
;  173	}
L_51:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _getOppositeDirection ***************************
;Name                         Addr/Register   Size   Type
;_5temp44                            STATIC     12   variable
;_4temp43                            STATIC     12   variable
;old                                  IX-28     12   variable
;new                                  IX-16     12   variable
;G_0                                   IX-4      3   variable
;i                                     IX-1      1   variable
;dir                                   IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_4temp43:
	DW	0
	DB	0
	DW	1
	DB	0
	DW	2
	DB	0
	DW	3
	DB	0
_5temp44:
	DW	1
	DB	0
	DW	0
	DB	0
	DW	3
	DB	0
	DW	2
	DB	0
	SEGMENT CODE
;  174	
;  175	
;  176	/* only one direction allowed at a time
;  177	 * safely moves the player. Should be called even if we know that the tile in a certain direction is solid.
;  178	 * Does not actually update player's position yet.
;  179	 * @param dx x displacement
;  180	 * @param dy y displacement
;  181	 * @returns a 'pipe_t' or NULL if not found.*/
;  182	void movePlayer(char dx, char dy) {
_movePlayer:
	LD	HL,-37
	CALL	__frameset
;  183		const tile_t tile = chkCollision(player.x + dx, player.y + dy);
	LD	A,(_player+1)
	ADD	A,(IX+9)
	LD	C,A
	LD	A,(_player)
	LD	B,0
	PUSH	BC
	ADD	A,(IX+6)
	LD	C,A
	PUSH	BC
	PEA	IX+-28
	CALL	_chkCollision
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+-14
	LD	BC,7
	LDIR	
;  184	
;  185		// if we found a pipe
;  186		if(pipeFromIndex(tile.id)) {
	LD	C,(IX+-8)
	LD	B,0
	PUSH	BC
	CALL	_pipeFromIndex
	POP	BC
	CALL	__icmpzero
	JR	Z,L_59
;  187			// check if we moved that tile, if so, move player, else return
;  188			if(moveTile(player.x + dx, player.y + dy, player.direction))
	LD	A,(_player+1)
	LD	BC,(_player+2)
	PUSH	BC
	ADD	A,(IX+9)
	LD	C,A
	LD	A,(_player)
	LD	B,0
	PUSH	BC
	ADD	A,(IX+6)
	LD	C,A
	PUSH	BC
	CALL	_moveTile
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_52
;  189				goto forceMove;
;  190			else
;  191				return;
	JR	L_62
;  192		}
L_59:
;  193	
;  194	
;  195		// if we are pulling a pipe
;  196		if(player.isPulling) {
	LD	A,(_player+6)
	OR	A,A
	JR	Z,L_61
;  197			const Direction d = getOppositeDirection(player.direction);
	LD	BC,(_player+2)
	PUSH	BC
	CALL	_getOppositeDirection
	POP	BC
	LD	(IX+-7),HL
;  198			const Position pos = facingOffset(d);
	LD	BC,HL
	PUSH	BC
	PEA	IX+-30
	CALL	_facingOffset
	POP	BC
	POP	BC
	LEA	DE,IX+-4
	LD	BC,2
	LDIR	
;  199			const uint8_t x = player.x + (char)pos.x, y = player.y + (char)pos.y;
	LD	A,(_player)
	ADD	A,(IX+-4)
	LD	(IX+-1),A
	LD	A,(_player+1)
	ADD	A,(IX+-3)
	LD	(IX+-2),A
;  200			const tile_t t = chkCollision(x, y);
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	PEA	IX+-37
	CALL	_chkCollision
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+-21
	LD	BC,7
	LDIR	
;  201	
;  202			if(IS_PIPE(t) && !isSolid(tile.id))
	LD	HL,(IX+-18)
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_61
	LD	C,(IX+-8)
	LD	B,0
	PUSH	BC
	CALL	_isSolid
	POP	BC
	OR	A,A
	JR	NZ,L_61
;  203				moveTile(x, y, player.direction);
	LD	BC,(_player+2)
	PUSH	BC
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	CALL	_moveTile
	POP	BC
	POP	BC
	POP	BC
;  204			
;  205		}
L_61:
;  206	
;  207	
;  208		// initate move if tile is not solid and we are not currently moving
;  209		if(!isSolid(tile.id)) {
	LD	C,(IX+-8)
	LD	B,0
	PUSH	BC
	CALL	_isSolid
	POP	BC
	OR	A,A
	JR	NZ,L_62
L_52:
;  210	forceMove:
;  211			player.isMoving = true;
	LD	A,1
	LD	(_player+5),A
;  212			player.dx = dx != 0;
	LD	A,(IX+6)
	OR	A,A
	JR	Z,L__36
	LD	A,1
	JR	L__37
L__36:
	XOR	A,A
L__37:
	LD	(_player+8),A
;  213			player.dy = dy != 0;
	LD	A,(IX+9)
	OR	A,A
	JR	Z,L__39
	LD	A,1
	JR	L__40
L__39:
	XOR	A,A
L__40:
	LD	(_player+9),A
;  214		}
;  215	
;  216	}
L_62:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _movePlayer ***************************
;Name                         Addr/Register   Size   Type
;_isSolid                            IMPORT  -----   function
;_facingOffset                       IMPORT  -----   function
;_getOppositeDirection               IMPORT  -----   function
;_moveTile                           IMPORT  -----   function
;_pipeFromIndex                      IMPORT  -----   function
;_player                             IMPORT     10   variable
;_chkCollision                       IMPORT  -----   function
;t                                    IX-21      7   variable
;tile                                 IX-14      7   variable
;d                                     IX-7      3   variable
;pos                                   IX-4      2   variable
;y                                     IX-2      1   variable
;x                                     IX-1      1   variable
;dy                                    IX+9      1   parameter
;dx                                    IX+6      1   parameter


; Stack Frame Size: 49 (bytes)
;       Spill Code: 0 (instruction)


;  217	
;  218	/* Pushs a tile at (x, y) in a direction.
;  219	 * Performs checks to ensure the tile can be pushed.
;  220	 * @param x x coordinate.
;  221	 * @param y y coordinate.
;  222	 * @param dir direction to push the tile.
;  223	 * @returns a 'pipe_t' or NULL if not found.*/
;  224	bool moveTile(uint8_t x, uint8_t y, Direction dir) {
_moveTile:
	LD	HL,-34
	CALL	__frameset
;  225		const Position pos = facingOffset(dir);
	LD	BC,(IX+12)
	PUSH	BC
	PEA	IX+-20
	CALL	_facingOffset
	POP	BC
	POP	BC
	LEA	DE,IX+-4
	LD	BC,2
	LDIR	
;  226		const uint8_t newX = x + (char)pos.x, newY = y + (char)pos.y;
	LD	A,(IX+-4)
	ADD	A,(IX+6)
	LD	(IX+-1),A
	LD	A,(IX+-3)
	ADD	A,(IX+9)
	LD	(IX+-2),A
;  227		const tile_t newTile = chkCollision(newX, newY);
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	PEA	IX+-27
	CALL	_chkCollision
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+-18
	LD	BC,7
	LDIR	
;  228		tile_t tile = getTile(x, y);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+6)
	PUSH	BC
	PEA	IX+-34
	CALL	_getTile
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+-11
	LD	BC,7
	LDIR	
;  229	
;  230		if (newTile.id == 0 && isPushable(tile.id)) {
	LD	A,(IX+-12)
	OR	A,A
	JR	NZ,L_65
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	CALL	_isPushable
	POP	BC
	OR	A,A
	JR	Z,L_65
;  231			setTile(newX, newY, &tile);
	PEA	IX+-11
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	CALL	_setTile
	POP	BC
	POP	BC
	POP	BC
;  232			setTile(x, y, NULL);
	LD	BC,0
	PUSH	BC
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+6)
	PUSH	BC
	CALL	_setTile
	POP	BC
	POP	BC
	POP	BC
;  233			return true;
	LD	A,1
	JR	L_66
;  234		}
L_65:
;  235		
;  236		return false;
	XOR	A,A
;  237	}
L_66:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _moveTile ***************************
;Name                         Addr/Register   Size   Type
;_setTile                            IMPORT  -----   function
;_isPushable                         IMPORT  -----   function
;_getTile                            IMPORT  -----   function
;_chkCollision                       IMPORT  -----   function
;_facingOffset                       IMPORT  -----   function
;newTile                              IX-18      7   variable
;tile                                 IX-11      7   variable
;pos                                   IX-4      2   variable
;newY                                  IX-2      1   variable
;newX                                  IX-1      1   variable
;dir                                  IX+12      3   parameter
;y                                     IX+9      1   parameter
;x                                     IX+6      1   parameter


; Stack Frame Size: 49 (bytes)
;       Spill Code: 0 (instruction)


;  238	
;  239	/* All pipes must be register in `pipes` array so this
;  240	 * routine can idenify them
;  241	 * @param tile index of a tile
;  242	 * @returns a 'pipe_t' or NULL if not found.*/
;  243	const pipe_t *pipeFromIndex(const uint8_t tile) {
_pipeFromIndex:
	LD	HL,-11
	CALL	__frameset
;  244		uint8_t i;
;  245	
;  246		for(i = 0; i < PIPES_SIZE; i++) {
	LD	(IX+-1),0
	JR	L_71
L_69:
;  247			if(lookupTile(tile).id == pipes[i].id) 
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_pipes
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	PEA	IX+-11
	CALL	_lookupTile
	POP	BC
	POP	BC
	LD	IY,(IX+-4)
	LD	A,(HL)
	CP	A,(IY+1)
	JR	NZ,L_70
;  248				return &pipes[i];
	LD	HL,(IX+-4)
	JR	L_73
;  249		}
L_70:
	INC	(IX+-1)
L_71:
	LD	A,(IX+-1)
	CP	A,8
	JR	C,L_69
	OR	A,A
;  250	
;  251		return NULL;
	SBC	HL,HL
;  252	}
L_73:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _pipeFromIndex ***************************
;Name                         Addr/Register   Size   Type
;_lookupTile                         IMPORT  -----   function
;_pipes                              IMPORT  unknown variable
;G_1                                   IX-4      3   variable
;i                                     IX-1      1   variable
;tile                                  IX+6      1   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


;  253	
;  254	// lookups an index in 'tileSprites'
;  255	tilesprite_t lookupTile(uint8_t index) {
_lookupTile:
	LD	HL,-7
	CALL	__frameset
;  256		const tilesprite_t t = tileset[index];
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__imul_b
	LD	BC,_tileset
	ADD	HL,BC
	LEA	DE,IX+-7
	LD	BC,7
	LDIR	
;  257	
;  258		if(index != t.id)
;  259			dbg_sprintf(dbgerr, "lookupTile Error.\nIndex passed: %d\nExpected Index: %d\n", index, t.id);
;  260		return t;
	LEA	HL,IX+6
	LD	DE,(HL)
	LEA	HL,IX+-7
	LD	BC,7
	LDIR	
	LD	HL,(IX+6)
	LD	SP,IX
	POP	IX
	RET	


;**************************** _lookupTile ***************************
;Name                         Addr/Register   Size   Type
;_tileset                            IMPORT    147   variable
;t                                     IX-7      7   variable
;index                                 IX+9      1   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


	XREF _drainWater:ROM
	XREF _initFlows:ROM
	XREF _drawTile:ROM
	XREF _tileset:ROM
	XREF _pipes:ROM
	XREF _curLevel:ROM
	XREF _player:ROM
	XREF __imuls:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XDEF _lookupTile
	XDEF _pipeFromIndex
	XDEF _moveTile
	XDEF _movePlayer
	XDEF _getOppositeDirection
	XDEF _newPosition
	XDEF _addPosition
	XDEF _updatePlayer
	XDEF _setTile
	XDEF _getTilePointerSafely
	XDEF _getTilePointer
	XDEF _getTile
	XDEF _chkCollision
	XDEF _facingOffset
	XDEF _isSpout
	XDEF _isPushable
	XDEF _isSolid
	END
